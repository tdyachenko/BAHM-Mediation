install.packages(c("DT", "shiny", "shinycssloaders", "shinydashboard", "shinyWidgets"))
install.packages(c("doFuture", "dplyr", "DT", "readr", "shiny"))
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
FUN_Mediation_LCRM_2class_MS_Gibbs_forShinyApp = function(Data, Prior, Mcmc, p = NULL)
{
myunireg = function(y, X, betabar, A, nu, q)  # Generate beta and sigma2
{
n    = length(y)
nvar = ncol(X)
RA   = chol(A)
W    = rbind(X, RA)
z    = c(y, as.vector(RA %*% betabar))
IR   = backsolve(chol(crossprod(W)), diag(nvar))
btilde = crossprod(t(IR)) %*% crossprod(W, z)
res    = z - W %*% btilde   # Traditional
s     = t(res) %*% res
done = 0
while (done == 0) {
sigma2 = ((nu * q + s)/rchisq(1, nu + n))
done = c(ifelse(sigma2>0.01, 1, 0))
}
beta = btilde + as.vector(sqrt(sigma2)) * IR %*% rnorm(nvar)
return(list(beta=beta, sigma2=sigma2))
}
# Inputs
nvarX = ncol(Data$X) # including intercept
nvarM = ncol(Data$m) # no intercept
m     = Data$m
X     = Data$X
y     = Data$y
nobs  = length(y)
dima  = ncol(X)   # dim of alpha
dimg  = ncol(X)   # dim of gamma
dimgb = dimg +1
R     = Mcmc$Rep
keep  = Mcmc$keep
if (missing(Prior)) {
ma  = c(rep(0, dima))     # mean of alpha
Aa  = 0.01 * diag(dima)
mgb = c(rep(0, (dimgb)))   # mean of betagamma
Agb = 0.01 * diag(dimgb)
nu  = 5
qy  = c(var(y),var(y))
qm  = c(var(m),var(m))
g   = 3          # this is nu and q for the prior distribution for rho in (52)
} else {
ma  = Prior$ma
Aa  = Prior$Aa
mgb = Prior$mgb
Agb = Prior$Agb
nu  = Prior$nu
qy  = Prior$qy   # vector (M,G)
qm  = Prior$qm   # vector (M,G)
g   = Prior$g    # this is nu and q for the prior distribution for rho in (52)
}
if (is.null(qy)==T) {  qy = c(var(y),var(y))  }
else                {  qy = Prior$qy }
if (is.null(qm)==T) {  qm = c(var(m),var(m))  }
else                {  qm = Prior$qm }
set.seed(Mcmc$seed)
# Set up storage
alphadraw = array(0, dim = c(floor(R/keep), dima, 2))        # 2 classes
betaMdraw = array(0, dim = c(floor(R/keep), 2))
gammabetaSdraw = array(0, dim = c(floor(R/keep), dimgb))
sigma2mdraw    = array(0, dim = c(floor(R/keep), 2))
sigma2ydraw    = array(0, dim = c(floor(R/keep), 2))
#LLdraw      = matrix(double(floor(R/keep) * nobs), ncol = nobs)
#LLtotaldraw = c(0,floor(R/keep))
rhodraw = matrix(0,ncol=1,nrow=floor(R/keep))
wdraw   = matrix(0,ncol=floor(R/keep),nrow=nobs)
LL_total = c(rep(0,floor(R/keep)))
LL       = array(0,dim=c(4,nobs,floor(R/keep)))
temp     = c(rep(0,nobs))
# Set up initial values
rho = 0.5
w   = c(rbinom(nobs,1,rho))
#  Mediating
alphaM = matrix(0,ncol=1,nrow=nvarX)
betaM  = matrix(0,ncol=1,nrow=nvarM+1)
sigma2yM = 1
sigma2mM = 1
#  Standard
alphaD     = matrix(0,ncol=1,nrow=nvarX)
gammabetaD = matrix(0,ncol=1,nrow=nvarM+nvarX)
sigma2yD = 1
sigma2mD = 1
itime = proc.time()[3]
cat("MCMC Iteration (est time to end - min)", fill = TRUE)
# begin loop
for(r in 1:R)
{
###  Segment 1 (called M here)
indexM = c(which(w==1))
yM = y[indexM]
mM = m[indexM]
XM = matrix(X[indexM,],ncol=nvarX)
if(1){
out_Xtom = myunireg(y=mM,X=XM,betabar=ma,A=Aa,nu=nu,q=qm[1])
alphaM   = out_Xtom$beta
sigma2mM = out_Xtom$sigma2
}
if(1){
out_mtoyM = myunireg(y=yM, X=cbind(rep(1,length(mM)), mM), betabar=mgb[1:2], A=Agb[1,1]*diag(2), nu=nu, q=qy[1])   # one mediator
betaM = out_mtoyM$beta
sigma2yM = out_mtoyM$sigma2
}
###  Segment 2 (called D here, but is S=standard segment)
indexD = c(which(w==0))
yD = y[indexD]
mD = m[indexD]
XD = matrix(X[indexD,],ncol=nvarX)
if(1){
out_Xtom = myunireg(y=mD,X=XD,betabar=ma,A=Aa,nu=nu,q=qm[2])
alphaD = out_Xtom$beta
sigma2mD = out_Xtom$sigma2
}
if(1){
out_mtoyD = myunireg(y=yD,X=cbind(XD,mD),betabar=mgb,A=Agb,nu=nu,q=qy[2])
gammabetaD=out_mtoyD$beta
sigma2yD = out_mtoyD$sigma2
}
####  Updating segment indicators
if(1){
LLikM = exp(-0.5*(log(c(2*pi*sigma2yM))+log(c(2*pi*sigma2mM))) - 0.5*(m-X%*%(alphaM))^2/ c(sigma2mM) - 0.5*(y-cbind(X[,1],m)%*%betaM)^2 / c(sigma2yM))
LLikD = exp(-0.5*(log(c(2*pi*sigma2yD))+log(c(2*pi*sigma2mD))) - 0.5*(m-X%*%(alphaD))^2/ c(sigma2mD) - 0.5*(y-cbind(X,m)%*%gammabetaD)^2 / c(sigma2yD))
temp = rho*LLikM/ (rho*LLikM+(1-rho)*LLikD)   #  pi in documents
for(hh in 1:nobs){
temppi = ifelse(is.finite(temp[hh])==T,ifelse(temp[hh]>1,1,temp[hh]),0)    # pi in documents
w[hh] = rbinom(1,1,temppi)
}
}
####  Updating segment probability
if(1){
rho = rbeta(1,g+sum(w),g+nobs-sum(w))
}
####   Save draws
if (r%%keep == 0){
mkeep = r/keep
alphadraw[mkeep,,1] = alphaM
alphadraw[mkeep,,2] = alphaD
betaMdraw[mkeep,] = betaM
gammabetaSdraw[mkeep,] = gammabetaD
sigma2mdraw[mkeep,] = c(sigma2mM,sigma2mD)
sigma2ydraw[mkeep,] = c(sigma2yM,sigma2yD)
rhodraw[mkeep] = rho        # used to be phi
wdraw[,mkeep] = w
LL_total[mkeep]= sum(log(LLikM[indexM])) + sum(log(LLikD[indexD]))
LL[1:2,,mkeep] = cbind(LLikM,LLikD)
}
mkeep = r/keep
if ((r%%100) == 0){
ctime = proc.time()[3]
timetoend = ((ctime - itime)/r) * (R - r)
cat(" ", r, "(", round(timetoend/60, 1), ")",fill=T)
if (!is.null(p)) p()
}
}
ctime = proc.time()[3]
cat(" Total Time Elapsed: ", round((ctime - itime)/60, 2),fill = TRUE)
return(list(alphadraw=alphadraw,betaMdraw=betaMdraw,gammabetaSdraw=gammabetaSdraw,sigma2mdraw=sigma2mdraw,
sigma2ydraw=sigma2ydraw,rhodraw=rhodraw,wdraw=wdraw,LL=LL,LL_total=LL_total,
Aa=Aa,ma=ma, mgb=mgb,Agb=Agb,nu=nu,qy=qy,qm=qm,g=g,R=R,keep=keep,seed=Mcmc$seed))
}
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
